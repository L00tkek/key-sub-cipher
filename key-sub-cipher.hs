import Data.Char
import System.IO

--The first four methods handle the IO part of this program. Separating them into four methods allows them to be
--looped easily.

main :: IO()
main = do
    hSetBuffering stdout NoBuffering
    putStrLn "This program encodes and decodes messages." 
    pickMode 
    
pickMode :: IO()
pickMode = do
    putStr "Please enter 'e' for encoding, 'd' for decoding, or 'q' to quit: "
    (c:_) <- getLine
    if (toLower c) == 'e'
        then doEncode
        else if (toLower c) == 'd'
            then doDecode
            else if (toLower c) == 'q'
                then putStrLn "Exiting."
                else pickMode

doEncode :: IO()
doEncode = do
    putStr "Please enter your message: "
    msg <- getLine
    putStr "Please enter the keyword: "
    key <- getLine
    putStrLn ("The encoded message is: " ++ (encode msg key) ++ "\n")
    pickMode

doDecode :: IO()
doDecode = do
    putStr "Please enter your message: "
    msg <- getLine
    putStr "Please enter the keyword: "
    key <- getLine
    putStrLn ("The decoded message is: " ++ (decode msg key) ++ "\n")
    pickMode

--The program uses a function that encrypts each letter by substituting the letter in the unencrypted message with a
--new letter. The encode and decode functions edit the message strings to make them easier to handle and then map
--the encryption/decryption function onto each letter in the message.

encode :: String -> String -> String
encode m k = map (subLettersE key) msg
    where
        msg = map toLower m
        key = map toLower k

decode :: String -> String -> String
decode m k = map (subLettersD key) msg
    where
        msg = map toLower m
        key = map toLower k

--The encryption algorithm here essentially finds out the number of the character in the alphabet (e.g. the letter 'a'
--would be 1, 'b' would be 2, etc.) and then substitutes the character at the same index in the key string. The key
--string is generated by rearranging the alphabet such that the letters inside the key word come first and then
--the rest of the letters in the alphabet follow in alphabetical order. Thus the keyword "WORD" generates the string
--"WORDABCEFGHIJKLMNPQSTVXYZ"

subLettersE :: String -> Char -> Char
subLettersE key char = if ('a' <= char && char <= 'z') then thingAt keyStr (indexOf alpha char) else char
    where
        keyStr = unDuplicate(key ++ ['a'..'z'])
        alpha = ['a'..'z']

subLettersD :: String -> Char -> Char
subLettersD key char = if ('a' <= char && char <= 'z') then thingAt alpha (indexOf keyStr char) else char
    where
        keyStr = unDuplicate(key ++ ['a'..'z'])
        alpha = ['a'..'z']

unDuplicate :: [Char] -> [Char]
unDuplicate word = reverse(go word [])
    where
        go [] acc = acc
        go (c:cs) acc = go cs (if hasChar c acc then acc else (c:acc))

hasChar :: Char -> String -> Bool
hasChar ch [] = False
hasChar ch (c:cs) = if (c == ch) then True else hasChar ch cs

thingAt :: [a] -> Int -> a
thingAt (x:xs) 0 = x
thingAt (x:xs) index = thingAt xs (index - 1)

indexOf :: Eq a => [a] -> a -> Int
indexOf list thing = go list thing 0
    where
        go [] _ _ = -1
        go (x:xs) thing i = if x == thing then i else go xs thing (i + 1)
